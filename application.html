<!DOCTYPE html>
<html lang="en">
  <!-- Full Handshack Deployment -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IRLid – Application</title>

  <link rel="stylesheet" href="css/style.css">

  <style>
    #scanner {
      width: 320px;
      height: 320px;
      margin: 16px auto;
      border: 2px dashed #999;
      border-radius: 12px;
      overflow: hidden;
      background: #f8f8f8;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #startCamBtn { position: relative; z-index: 9999; touch-action: manipulation; user-select:none; }
    #debug {
      max-width: 820px;
      margin: 12px auto 24px;
      text-align: left;
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      border: 1px solid #ddd;
      padding: 10px;
      border-radius: 10px;
      background: #fff;
      color: #111;
    }
    .small { max-width: 820px; margin: 10px auto; padding: 0 12px; }
    #responseArea { display:none; max-width: 820px; margin: 0 auto; text-align:center; }
    #responseQr { margin: 12px auto; }
  </style>
</head>

<body>
<header>
  <img src="logo.png" alt="In Real Life ID Logo" id="logo">
  <nav>
    <ul class="navbar">
      <li><a href="index.html">Home</a></li>
      <li><a href="application.html">Application</a></li>
      <li><a href="receipt.html">Receipt</a></li>
    </ul>
  </nav>
</header>

<main>
  <h2>Application (Mutual Scan + GPS)</h2>

  <p class="small" id="status">
    Step 1: Tap <b>Start Camera</b> and scan the other person’s Home QR.
  </p>

  <div class="small" style="text-align:center;">
    <button class="btn" id="startCamBtn" type="button">Start Camera</button>
  </div>

  <div id="scanner">
    <span id="scannerHint">Camera preview will appear here</span>
  </div>

  <div id="responseArea">
    <h3>Your Response QR</h3>
    <p class="small">
      This QR includes your <b>meeting signature</b> and a <b>signed GPS context</b>.
      Show it to the other person.
    </p>
    <div class="qr-box" id="responseQr"></div>
  </div>

  <div id="debug">Loading…</div>
</main>

<footer>
  IRLid — Proof of Personhood (Demo)
</footer>

<script src="js/sign.js"></script>
<script src="js/qr.js"></script>
<script src="https://unpkg.com/html5-qrcode"></script>

<script>
  const statusEl = document.getElementById("status");
  const debugEl  = document.getElementById("debug");
  const startBtn = document.getElementById("startCamBtn");
  const hintEl   = document.getElementById("scannerHint");
  const responseArea = document.getElementById("responseArea");

  function now() { return new Date().toISOString(); }
  function log(...args) {
    const line = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
    debugEl.textContent += "\n" + line;
  }
  function setStatus(msg) {
    statusEl.textContent = msg;
    log(now(), "STATUS:", msg);
  }

  // Show errors on-screen (mobile-friendly)
  window.addEventListener("error", (e) => log(now(), "WINDOW ERROR:", e.message || String(e)));
  window.addEventListener("unhandledrejection", (e) => {
    const r = e.reason;
    log(now(), "UNHANDLED REJECTION:", (r && (r.message || r.name || r)) || String(e));
  });

  debugEl.textContent = "";
  log(now(), "Loaded:", location.href);
  log(now(), "SecureContext:", window.isSecureContext);
  log(now(), "Html5Qrcode present:", (typeof Html5Qrcode !== "undefined"));

  // --- Helpers ---
  function parseMaybeHelloFromScannedText(scannedText) {
    const text = (scannedText || "").trim();

    // If it's a URL, extract HELLO from hash/query
    if (/^https?:\/\//i.test(text)) {
      try {
        const u = new URL(text);
        if (u.hash && u.hash.includes("HELLO=")) {
          const m = u.hash.match(/HELLO=([^&]+)/);
          if (m && m[1]) return m[1];
        }
        if (u.searchParams && u.searchParams.get("HELLO")) {
          return u.searchParams.get("HELLO");
        }
      } catch {}
    }

    // Otherwise treat it as base64url directly
    return text;
  }

  function isBase64Url(s) {
    return /^[A-Za-z0-9\-_]+$/.test(s || "");
  }

  function getGeoOnce({ timeoutMs = 12000, maxAgeMs = 15000, highAccuracy = true } = {}) {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error("Geolocation not supported."));
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (p) => resolve({
          lat: +p.coords.latitude.toFixed(7),
          lng: +p.coords.longitude.toFixed(7),
          acc: Math.round(p.coords.accuracy || 0),
          ts: Math.floor(Date.now() / 1000)
        }),
        (err) => reject(new Error(err?.message || "Geolocation failed / denied.")),
        { enableHighAccuracy: !!highAccuracy, timeout: timeoutMs, maximumAge: maxAgeMs }
      );
    });
  }

  function orderedPair(pubA, pubB) {
    const aStr = JSON.stringify(pubA);
    const bStr = JSON.stringify(pubB);
    return (aStr <= bStr) ? [pubA, pubB] : [pubB, pubA];
  }

  async function ctxHashFrom(mid, ctx) {
    const ctxPayload = {
      v: 1,
      type: "ctx",
      mid,
      ts: ctx.ts,
      lat: ctx.lat,
      lng: ctx.lng,
      acc: ctx.acc
    };
    const canon = canonical(ctxPayload);
    return b64urlEncode(await sha256Bytes(canon));
  }

  // --- Scanner ---
  let qr = null;
  let running = false;

  async function stopCamera() {
    try {
      if (qr && running) {
        await qr.stop();
        await qr.clear();
      }
    } catch (e) {
      log(now(), "Stop error:", e);
    } finally {
      running = false;
      qr = null;
    }
  }

  async function startScanOnce(onDecoded) {
    if (typeof Html5Qrcode === "undefined") {
      setStatus("ERROR: Scanner library didn't load (unpkg blocked/offline).");
      return;
    }
    if (!window.isSecureContext) {
      setStatus("ERROR: Not secure context (need HTTPS).");
      return;
    }

    setStatus("Listing cameras…");
    const cams = await Html5Qrcode.getCameras();
    log(now(), "Cameras:", cams);

    if (!cams || cams.length === 0) {
      setStatus("No cameras detected.");
      return;
    }

    // Pick rear camera if label suggests it
    let camId = cams[cams.length - 1].id;
    for (const c of cams) {
      const lbl = (c.label || "").toLowerCase();
      if (lbl.includes("back") || lbl.includes("rear") || lbl.includes("environment")) {
        camId = c.id; break;
      }
    }

    hintEl.textContent = "";
    qr = new Html5Qrcode("scanner");
    running = true;

    setStatus("Camera started. Point at the other person's QR…");

    await qr.start(
      { deviceId: { exact: camId } },
      { fps: 10, qrbox: 250 },
      async (decodedText) => {
        log(now(), "SCANNED:", decodedText);
        await stopCamera();
        await onDecoded(decodedText);
      },
      () => {}
    );
  }

  // --- IRLid Step 1: scan HELLO, build response QR ---
  async function handleHelloScan(decodedText) {
    setStatus("Processing scanned QR…");

    const raw = parseMaybeHelloFromScannedText(decodedText);

    if (!isBase64Url(raw)) {
      setStatus("That QR is not an IRLid HELLO payload.");
      log(now(), "Not base64url:", raw);
      return;
    }

    let hello;
    try {
      const helloJson = new TextDecoder().decode(b64urlDecode(raw));
      hello = JSON.parse(helloJson);
    } catch (e) {
      setStatus("Failed to decode HELLO payload.");
      log(now(), "Decode error:", e);
      return;
    }

    if (!hello || hello.type !== "hello" || !hello.pub) {
      setStatus("QR decoded, but not a valid HELLO payload.");
      log(now(), "Decoded object:", hello);
      return;
    }

    setStatus("HELLO decoded. Generating meeting + GPS context…");

    const myPub = await getPublicJwk();
    const theirPub = hello.pub;

    const [aPub, bPub] = orderedPair(myPub, theirPub);

    const payload = {
      v: 1,
      type: "meeting",
      a: aPub,
      b: bPub,
      t: Math.floor(Date.now() / 1000),
      method: "mutual-scan"
    };

    const mid = b64urlEncode(await sha256Bytes(canonical(payload)));
    const mySig = await signMid(mid);

    // GPS context (signed)
    setStatus("Requesting location permission…");
    const myCtx = await getGeoOnce();

    const myCtxHash = await ctxHashFrom(mid, myCtx);
    const myCtxSig  = await signMid(myCtxHash);

    const response = {
      v: 1,
      type: "response",
      payload,
      mid,
      sig: mySig,
      ctx: myCtx,
      ctxHash: myCtxHash,
      ctxSig: myCtxSig
    };

    const encodedResp = b64urlEncode(new TextEncoder().encode(JSON.stringify(response)));

    setStatus("Step 1 complete ✅ Show your Response QR to the other person.");
    responseArea.style.display = "block";
    makeQR("responseQr", encodedResp, 320);

    log(now(), "MID:", mid);
    log(now(), "My ctx:", myCtx);
    log(now(), "Response size (chars):", String(encodedResp.length));
  }

  // Button wiring
  startBtn.addEventListener("click", async () => {
    startBtn.disabled = true;
    try {
      await startScanOnce(handleHelloScan);
    } catch (e) {
      log(now(), "Start error:", e);
      setStatus("Camera failed to start: " + (e?.message || e));
      startBtn.disabled = false;
    }
  });
</script>

</body>
</html>
