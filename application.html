<!DOCTYPE html>
<!-- Deploy 19 -->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IRLid — Scan</title>
  <link rel="stylesheet" href="css/style.css">

  <style>
    :root{
      --black:#000;
      --white:#fff;
      --mobile-nav-h:124px;
      --side-pad:12px;
      --top-gap:10px;
    }

    html,body{height:100%;}
    body{margin:0;background:#fff;overflow-x:hidden;}

    header.site-header{width:100%;background:#fff;}
    .brand-wrap{padding:10px 14px 0;}
    .brand{display:inline-flex;text-decoration:none;color:inherit;align-items:center;}

    nav.site-nav{
      width:100%;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:0;
      padding:0;
      margin:0;
      position:sticky;
      top:0;
      z-index:1000;
    }

    a.nav-btn,summary.nav-btn{
      border:0;
      background:#000;
      color:#fff;
      padding:10px 14px;
      font-weight:700;
      border-radius:0;
      text-decoration:none;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      white-space:nowrap;
    }
    a.nav-btn:hover,summary.nav-btn:hover{background:#111;}

    details.nav-dropdown{position:relative;}
    details.nav-dropdown>summary{list-style:none;}
    details.nav-dropdown>summary::-webkit-details-marker{display:none;}

    .dropdown-menu{
      position:absolute;
      top:100%;
      left:0;
      background:#fff;
      border:1px solid #ddd;
      min-width:220px;
      border-radius:0;
      padding:0;
      z-index:1200;
    }
    .dropdown-menu a{
      display:block;
      padding:12px;
      font-weight:700;
      color:#000;
      text-decoration:none;
    }
    .dropdown-menu a:hover{background:#f2f2f2;}

    main.page-main{
      max-width:980px;
      margin:0 auto;
      padding:var(--top-gap) var(--side-pad) 20px;
      box-sizing:border-box;
    }

    .small{text-align:center; margin:8px 0;}

    /* Response must be ABOVE the scanner so the other person can immediately scan it */
    #responseArea{
      display:none;
      text-align:center;
      margin-top:10px;
      margin-bottom:10px;
    }
    #responseQr canvas, #responseQr img{
      display:block;
      margin:0 auto;
      max-width:100%;
      height:auto;
      image-rendering: pixelated;
    }

    #scanner{
      width:min(92vw,460px);
      height:min(92vw,460px);
      margin:10px auto 8px;
      border:2px dashed #999;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      overflow:hidden;
      background:#f8f8f8;
    }

    .controls{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin:10px 0;
    }

    /* Debug hidden by default */
    #debug{
      display:none;
      white-space:pre-wrap;
      font-family:monospace;
      font-size:12px;
      border:1px solid #ddd;
      padding:10px;
      margin-top:12px;
      box-sizing:border-box;
    }

    @media(max-width:720px){
      .brand-wrap{padding:4px var(--side-pad) 0;}
      #logo{max-width:72vw;max-height:90px;width:auto;height:auto;display:block;}

      nav.site-nav{
        position:fixed;
        top:auto; /* IMPORTANT */
        bottom:env(safe-area-inset-bottom,0);
        left:0;
        right:0;
        height:var(--mobile-nav-h);
        display:grid;
        grid-template-columns:1fr 1fr;
        grid-template-rows:1fr 1fr;
        z-index:2000;
      }

      a.nav-btn,summary.nav-btn{
        width:100%;
        height:100%;
        padding:0;
        font-size:18px;
      }

      .dropdown-menu{
        position:fixed;
        left:0;
        right:0;
        top:auto;
        bottom:calc(var(--mobile-nav-h) + env(safe-area-inset-bottom,0));
      }

      body{
        padding-bottom:calc(var(--mobile-nav-h) + env(safe-area-inset-bottom,0));
      }
    }
  </style>
</head>

<body>

<header class="site-header">
  <div class="brand-wrap">
    <a class="brand" href="index.html" aria-label="IRLid Home">
      <img src="logo.png" alt="IRLid Logo" id="logo">
    </a>
  </div>

  <nav class="site-nav" aria-label="Primary">
    <a class="nav-btn" href="index.html">Home</a>
    <a class="nav-btn" href="application.html">Scan</a>

    <details class="nav-dropdown">
      <summary class="nav-btn">About ▼</summary>
      <div class="dropdown-menu" role="menu" aria-label="About menu">
        <a href="about.html">About</a>
        <a href="features.html">Features</a>
        <a href="contact.html">Contact</a>
      </div>
    </details>

    <a class="nav-btn" href="receipt.html">Receipts</a>
  </nav>
</header>

<main class="page-main">
  <p id="status" class="small">Ready.</p>

  <div class="controls">
    <button class="btn" id="startBtn">Start Scanner</button>
    <button class="btn secondary" id="stopBtn">Stop</button>
  </div>

  <!-- IMPORTANT: response QR is above scanner -->
  <div id="responseArea">
    <h3 id="responseTitle">Your Return QR</h3>
    <div class="qr-box" id="responseQr"></div>
    <p class="small" id="responseHint" style="margin-top:8px;">
      Show this to the other person to scan.
    </p>
  </div>

  <div id="scanner"></div>

  <div class="small">
    <label for="cameraSelect"><b>Camera:</b></label><br>
    <select id="cameraSelect"></select>
  </div>

  <div id="debug"></div>
</main>

<script src="js/sign.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
<script src="https://unpkg.com/html5-qrcode"></script>
<script src="js/qr.js?v=layout11"></script>

<script>
  // Mutual validation thresholds
  const IRLID_TS_TOL_S = 60;
  const IRLID_DIST_TOL_M = 2;

  // Storage keys (kept simple; receipt.html reads these)
  const KEY_SELF  = "irlid_resp_self";
  const KEY_OTHER = "irlid_resp_other";

  const debugMode = new URLSearchParams(location.search).get("debug") === "1";
  const debugEl = document.getElementById("debug");
  if (debugMode) debugEl.style.display = "block";
  function log(...args){
    if (!debugMode) return;
    debugEl.textContent += "\n" + args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
  }

  const statusEl = document.getElementById("status");
  const cameraSelect = document.getElementById("cameraSelect");
  const responseArea = document.getElementById("responseArea");
  const responseTitle = document.getElementById("responseTitle");
  const responseHint = document.getElementById("responseHint");

  let scanner = null;

  function setStatus(s){ statusEl.textContent = s; }

  function clearStoredPair(){
    localStorage.removeItem(KEY_SELF);
    localStorage.removeItem(KEY_OTHER);
  }

  async function getGPS(){
    return new Promise((resolve) => {
      if (!navigator.geolocation) return resolve(null);
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy }),
        () => resolve(null),
        { enableHighAccuracy:true, timeout:6000, maximumAge:0 }
      );
    });
  }

  function pickRearCameraIndex(devices){
    const re = /(back|rear|environment)/i;
    const idx = devices.findIndex(d => re.test(d.label || ""));
    return idx >= 0 ? idx : 0;
  }

  async function listCameras(){
    try{
      const devices = await Html5Qrcode.getCameras();
      cameraSelect.innerHTML = "";
      devices.forEach((d,i)=>{
        const opt = document.createElement("option");
        opt.value = d.id;
        opt.textContent = d.label || `Camera ${i+1}`;
        cameraSelect.appendChild(opt);
      });
      if (devices.length) cameraSelect.selectedIndex = pickRearCameraIndex(devices);
      return devices;
    } catch(e){
      log("Camera list error:", String(e));
      return [];
    }
  }

  async function startScanner(handler){
    await stopScanner();
    scanner = new Html5Qrcode("scanner");

    const cam = cameraSelect.value || { facingMode: { ideal:"environment" } };

    try{
      await scanner.start(cam, { fps:10, qrbox:320 }, handler, () => {});
    } catch(e){
      log("Start error:", String(e));
      setStatus("Scanner failed to start.");
    }
  }

  async function stopScanner(){
    try{
      if (!scanner) return;
      await scanner.stop();
      await scanner.clear();
      scanner = null;
    } catch(e){
      log("Stop error:", String(e));
    }
  }

  function decodeHelloFromUrl(text){
    try{
      const u = new URL(text);
      const hash = u.hash || "";
      const m = hash.match(/HELLO=([A-Za-z0-9\-_]+)/);
      if (!m) return null;
      const bytes = b64urlDecode(m[1]);
      return JSON.parse(new TextDecoder().decode(bytes));
    } catch {
      return null;
    }
  }

  function decodeB64Json(text){
    try{
      const bytes = b64urlDecode(text);
      return JSON.parse(new TextDecoder().decode(bytes));
    } catch {
      return null;
    }
  }

  function decodeAny(text){
    const hello = decodeHelloFromUrl(text);
    if (hello) return hello;
    const obj = decodeB64Json(text);
    if (obj) return obj;
    return null;
  }

  function getHelloFromThisUrl(){
    try {
      const hash = location.hash || "";
      const m = hash.match(/HELLO=([A-Za-z0-9\-_]+)/);
      if (!m) return null;
      const bytes = b64urlDecode(m[1]);
      return JSON.parse(new TextDecoder().decode(bytes));
    } catch {
      return null;
    }
  }

  function showResponseQr(responseObj, titleText, hintText){
    const encoded = b64urlEncode(new TextEncoder().encode(JSON.stringify(responseObj)));
    makeQR("responseQr", encoded, 380);
    responseTitle.textContent = titleText;
    responseHint.textContent = hintText;
    responseArea.style.display = "block";
  }

  async function createResponseForMeeting(pubsOrdered, tsOverride){
    const myPub = await getPublicJwk();
    const gps = await getGPS();
    const ts = (typeof tsOverride === "number") ? tsOverride : Math.floor(Date.now()/1000);

    const payload = { v:1, type:"meeting", pubs: pubsOrdered, gps, ts };
    const response = await buildSignedResponseFromPayload(payload, myPub);

    localStorage.setItem(KEY_SELF, JSON.stringify(response));
    return response;
  }

  async function buildSignedResponseFromPayload(payload, myPub){
    // Compute hash of payload JSON (same as prior behavior)
    const payloadBytes = new TextEncoder().encode(JSON.stringify(payload));
    const hashB64 = await hashPayloadToB64url(payload); // from /js/sign.js helper
    const sigB64 = await signHashB64url(hashB64);       // from /js/sign.js helper

    return {
      v:1,
      type:"response",
      payload,
      hash: hashB64,
      sig: sigB64,
      pub: myPub
    };
  }

  function pubsOrderedFromTwo(pubA, pubB){
    return [pubA, pubB].sort((a,b)=>JSON.stringify(a).localeCompare(JSON.stringify(b)));
  }

  async function handleScannedResponse(text){
    const obj = decodeB64Json(text);
    if (!obj || obj.type !== "response"){
      setStatus("Not a Response QR.");
      return;
    }

    // Save "other" response
    localStorage.setItem(KEY_OTHER, JSON.stringify(obj));

    // If we don't already have a self response, create one immediately so the other person can scan it.
    let selfRaw = localStorage.getItem(KEY_SELF);
    if (!selfRaw) {
      try {
        const myPub = await getPublicJwk();
        const otherPub = obj.pub;
        const pubs = pubsOrderedFromTwo(myPub, otherPub);

        // Use their timestamp for perfect pairing (still validated within 60s; exact match is best)
        const theirTs = obj && obj.payload ? obj.payload.ts : null;
        const tsOverride = (typeof theirTs === "number") ? theirTs : undefined;

        const selfResp = await createResponseForMeeting(pubs, tsOverride);
        showResponseQr(
          selfResp,
          "Your Return QR",
          "Show this to the other person to scan, then both of you open Receipts."
        );
      } catch (e) {
        log("Auto-create self response failed:", String(e));
      }
    }

    setStatus("Saved. Opening combined receipt…");
    await stopScanner();
    location.href = "receipt.html";
  }

  async function handleScannedHello(text){
    const obj = decodeAny(text);

    // If user scans a Response while in HELLO mode, accept and process it.
    if (obj && obj.type === "response") {
      await handleScannedResponse(text);
      return;
    }

    if (!obj || obj.type !== "hello"){
      setStatus("Not a HELLO QR.");
      return;
    }

    // New meeting: clear any previous pair
    clearStoredPair();

    const hello = obj;
    setStatus("HELLO read. Creating your return QR…");

    const myPub = await getPublicJwk();
    const pubs = pubsOrderedFromTwo(myPub, hello.pub);

    const selfResp = await createResponseForMeeting(pubs, undefined);
    showResponseQr(
      selfResp,
      "Your Return QR",
      "Show this to the other person to scan. Then scan their return below."
    );

    setStatus("Now scan the other person's return QR below.");
  }

  // UI behavior:
  // - If page opened with #HELLO=... (from Home QR), auto-generate return QR immediately.
  // - Scanner in that case should be used to scan their return response (i.e., Response mode).
  let openedWithHello = false;

  document.getElementById("startBtn").onclick = async () => {
    if (openedWithHello) {
      setStatus("Scan their Return QR (Response).");
      await startScanner(handleScannedResponse);
      return;
    }
    setStatus("Scan the other person's Home QR (HELLO).");
    await startScanner(handleScannedHello);
  };

  document.getElementById("stopBtn").onclick = async () => {
    await stopScanner();
    setStatus("Stopped.");
  };

  (async () => {
    await listCameras();

    const helloFromUrl = getHelloFromThisUrl();
    if (helloFromUrl && helloFromUrl.type === "hello") {
      openedWithHello = true;

      // New meeting on open-from-Home flow
      clearStoredPair();

      try {
        setStatus("Opening from Home QR… generating return QR.");
        const myPub = await getPublicJwk();
        const pubs = pubsOrderedFromTwo(myPub, helloFromUrl.pub);

        const selfResp = await createResponseForMeeting(pubs, undefined);
        showResponseQr(
          selfResp,
          "Your Return QR",
          "Show this to the other person to scan. Then tap Start Scanner to scan their return."
        );

        setStatus("Show your Return QR above. Then scan their return when ready.");
      } catch (e) {
        log("Auto-generate response failed:", String(e));
        setStatus("Could not generate return QR (check permissions).");
      }
    } else {
      openedWithHello = false;
      setStatus("Ready. Tap Start Scanner to scan the other person's Home QR (HELLO).");
    }
  })();
</script>

</body>
</html>
